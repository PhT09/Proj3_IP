import streamlit as st
import cv2
import numpy as np
from io import BytesIO
from feature_funcs import (
    threshold_global, threshold_adaptive_mean, threshold_adaptive_gaussian,
    threshold_otsu, region_growing, watershed_segmentation,
    connected_components_detection, contour_detection, boundary_representation
)
from supporting_functions import (
    load_and_convert_image, resize_for_display, 
    overlay_edges_on_original, convert_to_pil
)

# C·∫•u h√¨nh trang
st.set_page_config(page_title="X·ª≠ l√Ω ·∫£nh - Segmentation", layout="wide")

# CSS ƒë·ªÉ gi·∫£m kho·∫£ng c√°ch v√† t·ªëi ∆∞u layout
st.markdown("""
<style>
    .block-container {padding-top: 1rem; padding-bottom: 0rem;}
    h1 {margin-bottom: 0.5rem; font-size: 1.8rem;}
    h2 {margin-top: 0.5rem; margin-bottom: 0.5rem; font-size: 1.3rem;}
    h3 {margin-top: 0.3rem; margin-bottom: 0.3rem; font-size: 1.1rem;}
    .stTabs [data-baseweb="tab-list"] {gap: 2px;}
</style>
""", unsafe_allow_html=True)

st.title("üñºÔ∏è X·ª≠ l√Ω ·∫£nh - Ph√¢n ƒëo·∫°n ·∫£nh (Segmentation)")

# Kh·ªüi t·∫°o session state
if 'original_image' not in st.session_state:
    st.session_state.original_image = None
if 'processed_image' not in st.session_state:
    st.session_state.processed_image = None
if 'chain_codes' not in st.session_state:
    st.session_state.chain_codes = None

# Layout ch√≠nh
col_control, col_display = st.columns([1, 2])

with col_control:
    st.header("ƒêi·ªÅu khi·ªÉn")
    
    # Upload ·∫£nh
    uploaded_file = st.file_uploader("Ch·ªçn ·∫£nh", type=['jpg', 'jpeg', 'png'], label_visibility="collapsed")
    
    if uploaded_file is not None:
        st.session_state.original_image = load_and_convert_image(uploaded_file)
        st.success("‚úÖ ƒê√£ t·∫£i ·∫£nh th√†nh c√¥ng!")
    
    # N√∫t x√≥a ·∫£nh
    if st.button("üóëÔ∏è X√≥a ·∫£nh hi·ªán t·∫°i", use_container_width=True):
        st.session_state.original_image = None
        st.session_state.processed_image = None
        st.session_state.chain_codes = None
        st.rerun()
    
    st.divider()
    
    # Ch·ªçn ch·ª©c nƒÉng
    if st.session_state.original_image is not None:
        st.subheader("Ch·ªçn ch·ª©c nƒÉng")
        
        function = st.selectbox(
            "Ph∆∞∆°ng ph√°p",
            ["L√†m s·∫Øc n√©t", "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng to√†n c·ª•c", "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng th√≠ch nghi (Trung b√¨nh)",
             "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng th√≠ch nghi (Gaussian)", "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng Otsu",
             "Ph√¢n ƒëo·∫°n d·ª±a tr√™n v√πng (Region Growing)", "Ph√¢n ƒëo·∫°n Watershed",
             "X√°c ƒë·ªãnh ƒë·ªëi t∆∞·ª£ng (Connected Components)", "X√°c ƒë·ªãnh ƒë·ªëi t∆∞·ª£ng (Contour)",
             "Bi·ªÉu di·ªÖn bi√™n (Chain Code)"],
            label_visibility="collapsed"
        )
        
        # Reset chain_codes khi ƒë·ªïi ch·ª©c nƒÉng
        if function != "Bi·ªÉu di·ªÖn bi√™n (Chain Code)":
            st.session_state.chain_codes = None
        
        # Reset seed_point khi kh√¥ng ph·∫£i Region Growing
        if function != "Ph√¢n ƒëo·∫°n d·ª±a tr√™n v√πng (Region Growing)":
            if 'seed_point' in st.session_state:
                st.session_state.seed_point = None
        
        # Tham s·ªë v√† x·ª≠ l√Ω t·ª± ƒë·ªông cho t·ª´ng ch·ª©c nƒÉng
        if function == "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng to√†n c·ª•c":
            threshold = st.slider("Ng∆∞·ª°ng", 0, 255, 127)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = threshold_global(st.session_state.original_image, threshold)
        
        elif function == "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng th√≠ch nghi (Trung b√¨nh)":
            block_size = st.slider("Block size", 3, 51, 11, 2)
            c_value = st.slider("C", -10, 10, 2)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = threshold_adaptive_mean(st.session_state.original_image, block_size, c_value)
        
        elif function == "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng th√≠ch nghi (Gaussian)":
            block_size = st.slider("Block size", 3, 51, 11, 2)
            c_value = st.slider("C", -10, 10, 2)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = threshold_adaptive_gaussian(st.session_state.original_image, block_size, c_value)
        
        elif function == "Ph√¢n ƒëo·∫°n ng∆∞·ª°ng Otsu":
            st.info("Kh√¥ng c·∫ßn tham s·ªë - T·ª± ƒë·ªông x√°c ƒë·ªãnh ng∆∞·ª°ng t·ªëi ∆∞u")
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = threshold_otsu(st.session_state.original_image)
        
        elif function == "Ph√¢n ƒëo·∫°n d·ª±a tr√™n v√πng (Region Growing)":
            st.write("Ch·ªçn seed point:")
            seed_x = st.slider("Seed X", 0, st.session_state.original_image.shape[1]-1, st.session_state.original_image.shape[1]//2)
            seed_y = st.slider("Seed Y", 0, st.session_state.original_image.shape[0]-1, st.session_state.original_image.shape[0]//2)
            threshold = st.slider("Ng∆∞·ª°ng", 1, 50, 10)
            
            # L∆∞u seed point v√†o session state
            st.session_state.seed_point = (seed_x, seed_y)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = region_growing(st.session_state.original_image, seed_x, seed_y, threshold)
        
        elif function == "Ph√¢n ƒëo·∫°n Watershed":
            morph_kernel = st.slider("Morphology kernel size", 3, 15, 5, 2)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = watershed_segmentation(st.session_state.original_image, morph_kernel)
        
        elif function == "X√°c ƒë·ªãnh ƒë·ªëi t∆∞·ª£ng (Connected Components)":
            min_area = st.slider("Di·ªán t√≠ch t·ªëi thi·ªÉu (pixels)", 10, 1000, 100, 10)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = connected_components_detection(st.session_state.original_image, min_area)
        
        elif function == "X√°c ƒë·ªãnh ƒë·ªëi t∆∞·ª£ng (Contour)":
            min_area = st.slider("Di·ªán t√≠ch t·ªëi thi·ªÉu (pixels)", 10, 1000, 100, 10)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            st.session_state.processed_image = contour_detection(st.session_state.original_image, min_area)
        
        elif function == "Bi·ªÉu di·ªÖn bi√™n (Chain Code)":
            min_area = st.slider("Di·ªán t√≠ch contour t·ªëi thi·ªÉu (pixels)", 10, 1000, 100, 10)
            
            # X·ª≠ l√Ω t·ª± ƒë·ªông
            result, chain_info = boundary_representation(st.session_state.original_image, min_area)
            st.session_state.processed_image = result
            st.session_state.chain_codes = chain_info
        
        # N√∫t t·∫£i xu·ªëng
        if st.session_state.processed_image is not None:
            st.divider()
            pil_img = convert_to_pil(st.session_state.processed_image)
            buf = BytesIO()
            pil_img.save(buf, format="PNG")
            st.download_button(
                label="‚¨áÔ∏è T·∫£i ·∫£nh k·∫øt qu·∫£",
                data=buf.getvalue(),
                file_name="result.png",
                mime="image/png",
                use_container_width=True
            )

# Hi·ªÉn th·ªã ·∫£nh
with col_display:
    st.header("Hi·ªÉn th·ªã ·∫£nh")
    
    if st.session_state.original_image is not None:
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("·∫¢nh g·ªëc")
            display_img = resize_for_display(st.session_state.original_image, max_width=400)
            
            # N·∫øu ƒëang d√πng Region Growing, v·∫Ω seed point
            if 'seed_point' in st.session_state and st.session_state.seed_point is not None:
                # T·∫°o b·∫£n sao ƒë·ªÉ v·∫Ω
                img_with_seed = display_img.copy()
                if len(img_with_seed.shape) == 2:
                    img_with_seed = cv2.cvtColor(img_with_seed, cv2.COLOR_GRAY2BGR)
                
                # T√≠nh t·ª∑ l·ªá resize ƒë·ªÉ ƒë·∫∑t seed point ƒë√∫ng v·ªã tr√≠
                original_h, original_w = st.session_state.original_image.shape[:2]
                display_h, display_w = display_img.shape[:2]
                scale_x = display_w / original_w
                scale_y = display_h / original_h
                
                # V·∫Ω seed point (ch·∫•m tr√≤n ƒë·ªè v√† ch·ªØ th·∫≠p)
                seed_x, seed_y = st.session_state.seed_point
                display_seed_x = int(seed_x * scale_x)
                display_seed_y = int(seed_y * scale_y)

                # V·∫Ω ƒëi·ªÉm nh·ªè ·ªü gi·ªØa
                cv2.circle(img_with_seed, (display_seed_x, display_seed_y), 2, (0, 0, 255), -1)
                
                st.image(img_with_seed, use_container_width=True, clamp=True)
            else:
                st.image(display_img, use_container_width=True, clamp=True)
        
        with col2:
            st.subheader("·∫¢nh k·∫øt qu·∫£")
            if st.session_state.processed_image is not None:
                display_result = resize_for_display(st.session_state.processed_image, max_width=400)
                st.image(display_result, use_container_width=True, clamp=True)
            else:
                st.info("Ch·ªçn ch·ª©c nƒÉng ƒë·ªÉ xem k·∫øt qu·∫£")
        
        # Hi·ªÉn th·ªã chain code n·∫øu c√≥
        if st.session_state.chain_codes is not None and len(st.session_state.chain_codes) > 0:
            st.divider()
            st.subheader("K·∫øt qu·∫£ Chain Code")
            for info in st.session_state.chain_codes:
                with st.expander(f"Contour {info['contour_id']} - Di·ªán t√≠ch: {info['area']:.0f}px"):
                    st.write(f"**ƒê·ªô d√†i chain code:** {info['chain_length']}")
                    st.write(f"**Chain code (50 s·ªë ƒë·∫ßu):** {info['chain_code'][:50]}")
                    if info['chain_length'] > 50:
                        st.caption(f"... v√† {info['chain_length'] - 50} s·ªë n·ªØa")
    else:
        st.info("üì§ Vui l√≤ng t·∫£i ·∫£nh l√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu")